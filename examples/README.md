# Examples

Here are some jupyter notebooks that experiment with loading architectures and using the codebase.

## Dataset serialization format

- `ROOT/count_hashes_under_radius_6.pkl`: entropy fingerprint count pickle for constructing entropy bits, auto generated by fp loader. Maps `(hash, center_atom, smiles, radius)` to `count` in retrieval set.
- `ROOT/index.pkl`: pickle file which stores idx: data dict mapping; example:
```python
    index = {
        0: {
            'has_hsqc': True,
            'has_c_nmr': False,
            'has_h_nmr': False,
            'has_mass_spec': True,
            'has_mw': True,
            'has_formula': True,
            'mw': 404.1099,
            'smiles': 'C=CC1CN2CCC1CC2C(O)c1ccnc2ccc(OC)cc12',
            'name': 'quinine hydrobromide',
            'split': 'train',
            'formula': 'C20H25BrN2O2',
            'np_pathway': ['Alkaloids'],
            'np_superclass': ['Tryptophan alkaloids'],
            'np_class': []
        },
        ...
    }
```
- `ROOT/metadata.json`: stores retrieval set metadata.
```python
    metadata['0'] = {
        "smiles": "CO[C@@H](C[C@@H](C)[C@H]1CC[C@@]2(C)[C@@H]3C=C[C@]45OCC3(CC[C@]12C)[C@@H]4CC[C@H](O[C@@H]1O[C@H](CO)[C@@H](O)[C@@H](O)[C@H]1O)C5(C)C)C=C(C)C",
        "canonical_3d_smiles": "CO[C@H](C=C(C)C)C[C@@H](C)[C@H]1CC[C@@]2(C)[C@@H]3C=C[C@]45OCC3(CC[C@]12C)[C@@H]4CC[C@H](O[C@@H]1O[C@H](CO)[C@@H](O)[C@@H](O)[C@H]1O)C5(C)C",
        "canonical_2d_smiles": "COC(C=C(C)C)CC(C)C1CCC2(C)C3C=CC45OCC3(CCC12C)C4CCC(OC1OC(CO)C(O)C(O)C1O)C5(C)C",
        "lotus": {
            "lotus_id": "LTS0122936",
            "name": "2-(hydroxymethyl)-6-{[8-(4-methoxy-6-methylhept-5-en-2-yl)-5,9,17,17-tetramethyl-18-oxapentacyclo[10.5.2.0\u00b9,\u00b9\u00b3.0\u2074,\u00b9\u00b2.0\u2075,\u2079]nonadec-2-en-16-yl]oxy}oxane-3,4,5-triol",
            "synonyms": [],
            "inchi": "InChI=1S/C37H60O8/c1-21(2)17-23(42-8)18-22(3)24-11-13-35(7)26-12-14-37-27(36(26,20-43-37)16-15-34(24,35)6)9-10-28(33(37,4)5)45-32-31(41)30(40)29(39)25(19-38)44-32/h12,14,17,22-32,38-41H,9-11,13,15-16,18-20H2,1-8H3",
            "inchikey": "NMIXDARFKVGBJR-UHFFFAOYSA-N"
        },
        "coconut": {
            "coconut_id": "CNP0118242.6",
            "name": "(2~{R},3~{S},4~{R},5~{R},6~{R})-2-(hydroxymethyl)-6-[[(1~{S},4~{R},5~{S},8~{R},9~{R},12~{R},13~{S},16~{S})-8-[(1~{R},3~{S})-3-methoxy-1,5-dimethyl-hex-4-enyl]-5,9,17,17-tetramethyl-18-oxapentacyclo[10.5.2.0^{1,13}.0^{4,12}.0^{5,9}]nonadec-2-en-16-yl]oxy]tetrahydropyran-3,4,5-triol",
            "synonyms": "",
            "inchi": "InChI=1S/C37H60O8/c1-21(2)17-23(42-8)18-22(3)24-11-13-35(7)26-12-14-37-27(36(26,20-43-37)16-15-34(24,35)6)9-10-28(33(37,4)5)45-32-31(41)30(40)29(39)25(19-38)44-32/h12,14,17,22-32,38-41H,9-11,13,15-16,18-20H2,1-8H3/t22-,23-,24-,25-,26-,27+,28+,29-,30-,31-,32+,34-,35+,36-,37+/m1/s1",
            "inchikey": "NMIXDARFKVGBJR-JFTCHSEGSA-N"
        },
        "npmrd": {
            "npmrd_id": "NP0288646",
            "name": "(2r,3s,4r,5r,6r)-2-(hydroxymethyl)-6-{[(1s,4s,5s,8r,9r,13s,16s)-8-[(2r,4s)-4-methoxy-6-methylhept-5-en-2-yl]-5,9,17,17-tetramethyl-18-oxapentacyclo[10.5.2.0\u00b9,\u00b9\u00b3.0\u2074,\u00b9\u00b2.0\u2075,\u2079]nonadec-2-en-16-yl]oxy}oxane-3,4,5-triol",
            "synonyms": null,
            "inchi": "InChI=1S/C37H60O8/c1-21(2)17-23(42-8)18-22(3)24-11-13-35(7)26-12-14-37-27(36(26,20-43-37)16-15-34(24,35)6)9-10-28(33(37,4)5)45-32-31(41)30(40)29(39)25(19-38)44-32/h12,14,17,22-32,38-41H,9-11,13,15-16,18-20H2,1-8H3/t22-,23-,24-,25-,26+,27+,28+,29-,30-,31-,32+,34-,35+,36?,37+/m1/s1",
            "inchikey": "NMIXDARFKVGBJR-CWAUVTJJSA-N"
        }
    }
```
- `ROOT/retrieval.pkl`
```python
    retrieval = {
        0: {'smiles': 'COC(C=C(C)C)CC(C)C1CCC2(C)C3C=CC45OCC3(CCC12C)C4CCC(OC1OC(CO)C(O)C(O)C1O)C5(C)C'},
        ...
    }
```
- `ROOT/RankingEntropy/rankingset.pt`: sparse CSR tensor mapping idx of retrieval to 1d tensor with fingerprints, 16384 length. Each entry is identical, pertaining to L2-normalized vector so that the 1d tensor has norm 1.
- `ROOT/RankingEntropy/bitinfo_to_idx.pkl`: autogenerated by fp loader.
- `ROOT/_lmdb`: stores spectra and fragmentation of each training entry.